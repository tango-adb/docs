---
sidebar_position: 4
---

# Operating the Decoder

## Create a decoder

```ts
import { ScrcpyVideoCodecId } from "@yume-chan/scrcpy";
import type { ScrcpyVideoDecoder } from "@yume-chan/scrcpy-decoder-tinyh264";
import type { VideoFrameRenderer } from "@yume-chan/scrcpy-decoder-webcodecs";

export declare class WebCodecsVideoDecoder implements ScrcpyVideoDecoder {
  constructor(options: WebCodecsVideoDecoder.Options);
}

export declare namespace WebCodecsVideoDecoder {
  export interface Options {
    codec: ScrcpyVideoCodecId;
    renderer: VideoFrameRenderer;
  }
}
```

The constructor requires two options:

- `codec`: the video codec to be decoded. It can be retrieved from the [video stream metadata](../index.mdx#video-stream-metadata), or hard-coded if you only use a specific video codec.
- `renderer`: a renderer created in the [Renderers](./renderer.mdx) section.

```ts transpile
import { WebCodecsVideoDecoder } from "@yume-chan/scrcpy-decoder-webcodecs";

const decoder = new WebCodecsVideoDecoder({
  codec: videoMetadata.codec,
  renderer: renderer,
});
```

### Pipe video stream

Similar to the TinyH264 decoder, after creating a decoder instance, you need to pipe the [video stream](./index.mdx#video-packets) into the `writable` property:

```ts transpile
import type { ScrcpyMediaStreamPacket } from "@yume-chan/scrcpy";

declare const videoPacketStream: ReadableStream<ScrcpyMediaStreamPacket>;

void videoPacketStream.pipeTo(decoder.writable).catch((e) => {
  console.error(e);
});
```

## Handle size changes

When the device orientation changes, Scrcpy server will recreate a new video encoder with the new size. The decoder will parse the new video configuration, and update the canvas size automatically.

However, the video size is also useful for other purposes, like [injecting touch events](../../control/touch.mdx). The `sizeChanged` event will be emitted when the video size changes:

```ts transpile
decoder.sizeChanged(({ width, height }) => {
  console.log(width, height);
});
```

## Take a screenshot

Because WebCodecs decoder can render to different types of targets, it's more difficult to manually capture the latest frame.

To help with that, the decoder provides the `snapshot` method to easily capture the last rendered frame as a PNG image.

```ts transpile
const blob: Blob | undefined = await decoder.snapshot();
```

If no frames has been rendered, the return value will be `undefined`. Otherwise it will be a [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) object with the PNG image data.
