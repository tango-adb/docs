---
sidebar_position: 2
---

# Renderers

WebCodecs API decodes video frames into `VideoFrame` objects. There are multiple methods to render those `VideoFrame` objects onto the page. This package provides three renderers:

:::info

These renderers are not tied to our `WebCodecsVideoDecoder`, they can also be used separately to render any `VideoFrame` objects from WebCodecs API.

:::

- `InsertableStreamVideoFrameRenderer`: Renders to a `<video>` element using [Insertable Streams API](https://developer.mozilla.org/en-US/docs/Web/API/Insertable_Streams_for_MediaStreamTrack_API). See [quirks](#quirks-of-insertable-stream-renderer) below.
- `WebGLVideoFrameRenderer`: Renders to a `<canvas>` or `OffscreenCanvas` using WebGL. It only works with hardware accelerated WebGL, because without hardware acceleration, the performance is even worse than the bitmap renderer below.
- `BitmapVideoFrameRenderer`: Renders to a `<canvas>` or `OffscreenCanvas` using bitmap renderer.

:::info

`VideoFrame`s can also be rendered using 2D canvas. However, because it's slower than bitmap renderer, and bitmap renderer is already available on all devices, we didn't think it's necessary to implement it.

:::

## Quirks of Insertable Stream renderer

The Insertable Streams renderer should be considered as experimental, because there are several issues around it:

#### Performance

The Insertable Streams API is specifically designed to render video frames from WebCodecs API, but in reality it's only easier to integrate, not faster. So it doesn't have the performance advantage over other renderers.

#### Compatibility

Its [specification](https://w3c.github.io/mediacapture-transform/) has two versions: the old `MediaStreamTrackGenerator` API, and the new `VideoTrackGenerator`. Only Chrome implemented the old API. The new API was added in mid 2023, but until end of 2024, nobody (including Chrome, who authored the specification), has implemented the new API ([Chrome issue](https://issues.chromium.org/issues/40058895), [Firefox issue](https://bugzilla.mozilla.org/show_bug.cgi?id=1749532)).

As a result, we implemented the Insertable Stream renderer using the old `MediaStreamTrackGenerator` API. We will monitor the situation and update the renderer if necessary.

#### Lifecycle

Because it renders to a `<video>` element, if the video element is removed from the DOM tree (e.g. to move it into another element, or another page), it will be automatically paused. You need to call `renderer.element.play()` to resume playback after adding it back to the DOM tree.

It sets the `autoplay` attribute on the `<video>` element, so it will start playing automatically for the first time.

## Create a renderer

Generally, the performance ranking is `InsertableStream` â‰ˆ `WebGL` >> `Bitmap`. However, because Insertable Stream renderer and WebGL renderer are not available on all devices, we recommend the following method to choose the best renderer on all devices:

`InsertableStreamVideoFrameRenderer` and `WebGLVideoFrameRenderer` both have an `isSupported` static property, to check whether they are supported by the current browser and hardware:

```ts transpile
import type { VideoFrameRenderer } from "@yume-chan/scrcpy-decoder-webcodecs";
import {
  InsertableStreamVideoFrameRenderer,
  WebGLVideoFrameRenderer,
  BitmapVideoFrameRenderer,
} from "@yume-chan/scrcpy-decoder-webcodecs";

function createVideoFrameRenderer(): {
  renderer: VideoFrameRenderer;
  element: HTMLVideoElement | HTMLCanvasElement;
} {
  // Uncomment following lines to enable InsertableStreamVideoFrameRenderer, see quirks above
  // if (InsertableStreamVideoFrameRenderer.isSupported) {
  //   const renderer = new InsertableStreamVideoFrameRenderer();
  //   return { renderer, element: renderer.element };
  // }

  if (WebGLVideoFrameRenderer.isSupported) {
    const renderer = new WebGLVideoFrameRenderer();
    return { renderer, element: renderer.canvas as HTMLCanvasElement };
  }

  const renderer = new BitmapVideoFrameRenderer();
  return { renderer, element: renderer.canvas as HTMLCanvasElement };
}
```

When the constructors are called without arguments, they will create a rendering target automatically (`<video>` element for `InsertableStreamVideoFrameRenderer`, `<canvas>` for `WebGLVideoFrameRenderer` and `BitmapVideoFrameRenderer`). You will need to insert the created `element` into the page to display the video:

```ts transpile
const { renderer, element } = createVideoFrameRenderer();
document.body.appendChild(element);
```

Or, all renderers accept existing rendering targets:

```ts transpile
new InsertableStreamVideoFrameRenderer(videoElement);
new WebGLVideoFrameRenderer(canvasElementOrOffscreenCanvas);
new BitmapVideoFrameRenderer(canvasElementOrOffscreenCanvas);
```