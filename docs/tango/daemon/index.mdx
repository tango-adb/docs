# Daemon transport

**AdbDaemonTransport** connects to ADB Daemons directly. This means it can run on devices without Google ADB (for example, on Web platforms where connecting to Google ADB Server is not supported, or on mobile devices where Google ADB is not available).

This is the lowest-level transport, it controls all the steps, including authentication, message encoding and decoding, and connection management.

```mermaid
flowchart LR
    subgraph PC
        CA["Client A"] <--> TA["Daemon Transport A"]
        CB["Client B"] <--> TB["Daemon Transport B"]
    end
    subgraph A["Device B"]
        TB <-->|USB| AD["ADB Daemon"]
    end
    subgraph B["Device A"]
        TA <-->|TCP| BD["ADB Daemon"]
    end
    subgraph PC
        S["Google ADB Server"] x-.-x|USB| AD
        O["Daemon Transport C"] x-.-x|USB| AD
    end
```

## Installation

This class is included in the core package:

```sh npm2yarn
npm i @yume-chan/adb
```

## Overview

To support different runtime and connection method, `AdbDaemonTransport` class itself only defines how to serialize and deserialize Daemon Protocol packets.

The most common usage is to use `AdbDaemonTransport.authenticate()` static method to create an authenticated transport instance. It uses an `AdbDaemonConnection` object to send and receive packets and an `AdbDaemonAuthenticator` implementation to handle handshake and authentication.

```mermaid
flowchart TD
    A[/an AdbDaemonConnection instance/] & B[/an AdbDaemonAuthenticator instance/] --> C["AdbDaemonTransport.authenticate()"] --> D[\an AdbDaemonTransport instance\] --> E["new Adb()"] --> F[\an Adb instance\]

    classDef link text-decoration: underline;
    class A,B,C,F link;

    click A "#connections"
    click B "./credential-store/"
    click C "./connect-device"
    click F "../../api/"
```

:::note

Click underlined nodes to open their relevant documentations.

:::

Alternatively, if your connection doesn't require authentication or you handle it yourself, you can directly create an `AdbDaemonTransport` instance using its constructor.

```mermaid
flowchart TD
    A[/an AdbDaemonConnection instance/] --> B["new AdbDaemonTransport()"]
    B --> C[\an AdbDaemonTransport instance\]
    C --> D["new Adb()"]
    D --> E[\an Adb instance\]

    classDef link text-decoration: underline;
    class A,E link;

    click A "#connections"
    click E "../../api/"
```

:::note

Click underlined nodes to open their relevant documentations.

:::

## Connections

Daemon Transport has three connection methods:

- **USB**: Uses USB API to communicate with devices connected via USB.
- **ADB over Wi-Fi** a.k.a TCP/IP Mode: Uses TCP sockets to communicate with devices over the network.
- **Wireless Debugging**: Added in Android 11. Uses TLS over TCP sockets and a new authentication process.

:::info

The Wireless Debugging connection is not implemented yet, as it needs a full TLS implementation.

We expect it to be a separate package if it uses third-party libraries, but we haven't found a suitable library yet. Any help is appreciated!

:::

Due to runtime API limitations, not all connections are supported on all environments:

| Connection         | Web                                               | Node.js   |
| ------------------ | ------------------------------------------------- | --------- |
| **USB**            | Supported on Chromium-based browsers <sup>1</sup> | Supported |
| **ADB over Wi-Fi** | Not supported                                     | Supported |

<sup>1</sup> Chrome for Android is supported, but Chrome for iOS is based on
Safari and not supported.

`AdbDaemonTransport` also accepts custom connection implementations. For example, with a Node.js WebSocket server that forwards packets to devices, a WebSocket connection can connect to that server and enable unsupported connections on Web platforms.

```mermaid
flowchart TD
    subgraph A [an AdbDaemonWebUsbDevice instance]
        B["connect()"]
    end

    B & C[/ADB over Wi-Fi connection/] --> D[\"an AdbDaemonConnection instance"\]
    D & E[/an AdbDaemonAuthenticator instance/] --> F["AdbDaemonTransport.authenticate()"] --> G[\an AdbDaemonTransport instance\] --> H["new Adb()"] --> I[\an Adb instance\]

    J[/Custom connection/] --> K["new AdbDaemonTransport()"] --> G

    classDef link text-decoration: underline;
    class B,C,E,F,J,I link;

    click B "#usb-connection"
    click C "#tcp-connection"
    click E "./credential-store/"
    click F "./connect-device"
    click J "#custom-connection"
    click I "./api/"
```

:::note

Click underlined nodes to open their relevant documentations.

:::

### USB Connection

USB connection is the oldest and most common way to connect to Android devices.

Because USB connections are exclusive, Daemon Transport can't access a USB device at the same time with Google ADB or other ADB clients. To do that, use the [Server Transport](../server/index.mdx).

[`@yume-chan/adb-daemon-webusb`](https://www.npmjs.com/package/@yume-chan/adb-daemon-webusb) package provides an `AdbDaemonConnection` implementation based on [WebUSB API](https://developer.mozilla.org/en-US/docs/Web/API/WebUSB_API):

* Chromium-based browsers support WebUSB natively. Chrome for Android is supported, but Chrome for iOS is based on Safari and not supported.
* Node.js can use the WebUSB implementation in the [`usb`](https://www.npmjs.com/package/usb) package.

```mermaid
flowchart TD
    N["AdbDaemonWebUsbDeviceManager.BROWSER<br/>(Shortcut for Web environment)"] --> M
    A[/"a USB instance<br/>(Runtime WebUSB API)"/] --> B["new AdbDaemonWebUsbDeviceManager()"]

    subgraph M ["an AdbDaemonWebUsbDeviceManager instance"]
        C["requestDevice()<br/>(Add a new device)"]
        D["getDevices()<br/>(Get existing devices)"]
        O["trackDevices()<br/>(Watch device changes)"]
    end

    subgraph E ["an AdbDaemonWebUsbDevice instance"]
        F["connect()"]
    end

    B --> M
    C & D & O --> E
    F --> G[\an AdbDaemonConnection instance\]

    classDef link text-decoration: underline;
    class B,N,C,D,O,F link;

    click B "./usb/device-manager"
    click N "./usb/device-manager"
    click C "./usb/request-device"
    click D "./usb/get-devices"
    click O "./usb/watch-devices"
    click F "./usb/create-connection"
```

:::note

Click underlined nodes to open their relevant documentations.

:::

:::note[Next Step]

[Create USB connection](./usb/index.mdx)

:::

### TCP Connection

ADB over Wi-Fi (a.k.a TCP/IP mode) uses TCP sockets to communicate with devices over the network. Google Android Emulators are also supported. The data protocol is completely same as USB connection, just on a different transport layer.

Currently, there is no built-in TCP connection for Web platforms, as TCP sockets are not supported there. This documentation provides a reference implementation for Node.js.

:::note[Next Step]

[Create TCP connection](./tcp/enable.mdx)

:::

### Custom Connection

In addition to the built-in connection methods, Tango also accepts custom connection implementations. For example, with a Node.js WebSocket server that forwards packets to devices, a WebSocket connection can connect to that server and enable unsupported connections on Web platforms.

```mermaid
flowchart LR
    subgraph A ["@yume-chan/adb"]
        AdbDaemonTransport
    end
    subgraph C ["your package"]
        AdbDaemonTransport <--> YourConnection
    end
    subgraph D ["Device"]
        YourConnection <-->|Custom Protocol| Daemon["ADB Daemon"]
    end
```

:::note[Next Step]

[Create custom connection](./custom-connection.mdx)

:::
